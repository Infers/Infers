<!DOCTYPE html>
<html>
<head>
<title>Infers.Rep Library Reference</title>
<style>
pre {
border: 1px solid #e0e0e0;
border-radius: 3px;
padding: 5px;
line-height: 160%;
background: #f7f7f7;
font-family: "Lucida Console", Monaco, monospace;
font-size: 72%;
}
code {
border: 1px solid #e0e0e0;
border-radius: 3px;
padding: 2px;
background: #f7f7f7;
font-family: "Lucida Console", Monaco, monospace;
font-size: 72%;
}
div.nested {
padding-left: 1.5em;
}
a {
text-decoration: none;
font-weight: bold;
}
</style>
</head>
<body><table width="80%" align="center"><tr><td>
<h1>Infers.Rep Library Reference</h1>
<p>This document provides a reference manual for the Infers.Rep library and is generated from the library source code.</p>
<h2>Synopsis</h2>
<pre><b>namespace</b> Infers<b>.</b><a id="dec:namespace Infers.Rep" href="#def:namespace Infers.Rep">Rep</a></pre>
<pre><b>[&lt;</b>InferenceRules<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.Rep" href="#def:type Infers.Rep.Rep">Rep</a>  <b>=</b>
  <b>new</b><b>:</b> unit <b>-&gt;</b> Rep
  <b>member</b> <a id="dec:member Infers.Rep.Rep.union" href="#def:member Infers.Rep.Rep.union">union</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Infers.Rep.Union">Union</a><b>&lt;</b><i>'u</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Infers.Rep.Rep.product" href="#def:member Infers.Rep.Rep.product">product</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Infers.Rep.Product">Product</a><b>&lt;</b><i>'p</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Infers.Rep.Rep.record" href="#def:member Infers.Rep.Rep.record">record</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Infers.Rep.Record">Record</a><b>&lt;</b><i>'r</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Infers.Rep.Rep.tuple" href="#def:member Infers.Rep.Rep.tuple">tuple</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Infers.Rep.Tuple">Tuple</a><b>&lt;</b><i>'t</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Infers.Rep.Rep.asElem" href="#def:member Infers.Rep.Rep.asElem">asElem</a><b>:</b> <a href="#def:type Infers.Rep.Field">Field</a><b>&lt;</b><i>'f</i>, <i>'sp</i>, <i>'r</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Infers.Rep.Elem">Elem</a><b>&lt;</b><i>'f</i>, <i>'sp</i>, <i>'r</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Infers.Rep.Rep.asElem" href="#def:member Infers.Rep.Rep.asElem">asElem</a><b>:</b> <a href="#def:type Infers.Rep.Label">Label</a><b>&lt;</b><i>'l</i>, <i>'sp</i>, <i>'sc</i>, <i>'u</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Infers.Rep.Elem">Elem</a><b>&lt;</b><i>'l</i>, <i>'sp</i>, <i>'u</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Infers.Rep.Empty" href="#def:type Infers.Rep.Empty">Empty</a>  <b>=</b> <b>struct</b> <b>end</b>
</pre>
<pre><b>[&lt;</b>Struct<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.And" href="#def:type Infers.Rep.And">And</a><b>&lt;</b><i>'x</i>, <i>'xs</i><b>&gt;</b> <b>=</b>
  <b>val</b> <b>mutable</b> <a id="dec:val Infers.Rep.And.Elem" href="#def:val Infers.Rep.And.Elem">Elem</a><b>:</b> <i>'x</i>
  <b>val</b> <b>mutable</b> <a id="dec:val Infers.Rep.And.Rest" href="#def:val Infers.Rep.And.Rest">Rest</a><b>:</b> <i>'xs</i>
</pre>
<pre><b>[&lt;</b>AbstractClass; InferenceRules<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.AsProduct" href="#def:type Infers.Rep.AsProduct">AsProduct</a><b>&lt;</b><i>'p</i>, <i>'t</i><b>&gt;</b> <b>=</b>
  <b>abstract</b> <a id="dec:abstract Infers.Rep.AsProduct.Extract" href="#def:abstract Infers.Rep.AsProduct.Extract">Extract</a><b>:</b> <i>'t</i> <b>*</b> byref<b>&lt;</b><i>'p</i><b>&gt;</b> <b>-&gt;</b> unit
  <b>abstract</b> <a id="dec:abstract Infers.Rep.AsProduct.Create" href="#def:abstract Infers.Rep.AsProduct.Create">Create</a><b>:</b> byref<b>&lt;</b><i>'p</i><b>&gt;</b> <b>-&gt;</b> <i>'t</i>
  <b>abstract</b> <a id="dec:abstract Infers.Rep.AsProduct.ToProduct" href="#def:abstract Infers.Rep.AsProduct.ToProduct">ToProduct</a><b>:</b> <i>'t</i> <b>-&gt;</b> <i>'p</i>
  <b>abstract</b> <a id="dec:abstract Infers.Rep.AsProduct.OfProduct" href="#def:abstract Infers.Rep.AsProduct.OfProduct">OfProduct</a><b>:</b> <i>'p</i> <b>-&gt;</b> <i>'t</i>
</pre>
<pre><b>[&lt;</b>AbstractClass; InferenceRules<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.AsChoice" href="#def:type Infers.Rep.AsChoice">AsChoice</a><b>&lt;</b><i>'c</i>, <i>'u</i><b>&gt;</b> <b>=</b> <b>class</b>
  <b>end</b>
</pre>
<pre><b>[&lt;</b>AllowNullLiteral; InferenceRules<b>&gt;]</b> 
<b>type</b> <a href="#def:type Infers.Rep.Rep">Rep</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> <b>class</b>
  <b>end</b>
</pre>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.Product" href="#def:type Infers.Rep.Product">Product</a><b>&lt;</b><i>'t</i><b>&gt;</b> <b>=</b>
  inherit Rep<b>&lt;</b><i>'t</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Infers.Rep.Product.Arity" href="#def:val Infers.Rep.Product.Arity">Arity</a><b>:</b> int
  <b>val</b> <a id="dec:val Infers.Rep.Product.IsMutable" href="#def:val Infers.Rep.Product.IsMutable">IsMutable</a><b>:</b> bool
</pre>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.Tuple" href="#def:type Infers.Rep.Tuple">Tuple</a><b>&lt;</b><i>'t</i><b>&gt;</b> <b>=</b>
  inherit <a href="#def:type Infers.Rep.Product">Product</a><b>&lt;</b><i>'t</i><b>&gt;</b>
</pre>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.Elem" href="#def:type Infers.Rep.Elem">Elem</a><b>&lt;</b><i>'e</i>, <i>'p</i>, <i>'t</i><b>&gt;</b> <b>=</b>
  <b>val</b> <a id="dec:val Infers.Rep.Elem.Index" href="#def:val Infers.Rep.Elem.Index">Index</a><b>:</b> int
  <b>abstract</b> <a id="dec:abstract Infers.Rep.Elem.Get" href="#def:abstract Infers.Rep.Elem.Get">Get</a><b>:</b> <i>'t</i> <b>-&gt;</b> <i>'e</i>
</pre>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.Union" href="#def:type Infers.Rep.Union">Union</a><b>&lt;</b><i>'u</i><b>&gt;</b> <b>=</b>
  inherit Rep<b>&lt;</b><i>'u</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Infers.Rep.Union.Arity" href="#def:val Infers.Rep.Union.Arity">Arity</a><b>:</b> int
  <b>abstract</b> <a id="dec:abstract Infers.Rep.Union.Tag" href="#def:abstract Infers.Rep.Union.Tag">Tag</a><b>:</b> <i>'u</i> <b>-&gt;</b> int
</pre>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.Case" href="#def:type Infers.Rep.Case">Case</a><b>&lt;</b><i>'lp</i>, <i>'sc</i>, <i>'u</i><b>&gt;</b> <b>=</b>
  inherit <a href="#def:type Infers.Rep.AsProduct">AsProduct</a><b>&lt;</b><i>'lp</i>, <i>'u</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Infers.Rep.Case.Name" href="#def:val Infers.Rep.Case.Name">Name</a><b>:</b> string
  <b>val</b> <a id="dec:val Infers.Rep.Case.Arity" href="#def:val Infers.Rep.Case.Arity">Arity</a><b>:</b> int
  <b>val</b> <a id="dec:val Infers.Rep.Case.Tag" href="#def:val Infers.Rep.Case.Tag">Tag</a><b>:</b> int
</pre>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.Label" href="#def:type Infers.Rep.Label">Label</a><b>&lt;</b><i>'l</i>, <i>'sp</i>, <i>'sc</i>, <i>'u</i><b>&gt;</b> <b>=</b>
  inherit Elem<b>&lt;</b><i>'l</i>, <i>'sp</i>, <i>'u</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Infers.Rep.Label.Name" href="#def:val Infers.Rep.Label.Name">Name</a><b>:</b> string
</pre>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.Record" href="#def:type Infers.Rep.Record">Record</a><b>&lt;</b><i>'r</i><b>&gt;</b> <b>=</b>
  inherit <a href="#def:type Infers.Rep.Product">Product</a><b>&lt;</b><i>'r</i><b>&gt;</b>
</pre>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="dec:type Infers.Rep.Field" href="#def:type Infers.Rep.Field">Field</a><b>&lt;</b><i>'f</i>, <i>'sp</i>, <i>'r</i><b>&gt;</b> <b>=</b>
  inherit Elem<b>&lt;</b><i>'f</i>, <i>'sp</i>, <i>'r</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Infers.Rep.Field.Name" href="#def:val Infers.Rep.Field.Name">Name</a><b>:</b> string
  <b>val</b> <a id="dec:val Infers.Rep.Field.IsMutable" href="#def:val Infers.Rep.Field.IsMutable">IsMutable</a><b>:</b> bool
  <b>abstract</b> <a id="dec:abstract Infers.Rep.Field.Set" href="#def:abstract Infers.Rep.Field.Set">Set</a><b>:</b> <i>'r</i> <b>*</b> <i>'f</i> <b>-&gt;</b> unit
</pre>
<h2>Description</h2>
<pre><b>namespace</b> Infers<b>.</b><a id="def:namespace Infers.Rep" href="#dec:namespace Infers.Rep">Rep</a>
</pre>
<div class="nested"><p> <code>Infers<b>.</b><a href="#def:namespace Infers.Rep">Rep</a></code> is a library providing inference rules for datatype generic programming with the <code>Infers</code> library.</p><p> <code>Infers<b>.</b><a href="#def:namespace Infers.Rep">Rep</a></code> uses reflection and run-time code generation to build type representations for various F# types.  Those type representations can be accessed using <code>Infers</code> by writing rules over the structure of types.  The type representations provided by <code>Infers<b>.</b><a href="#def:namespace Infers.Rep">Rep</a></code> make it possible to manipulate values of the represented types efficiently: after the type representation has been created, no further use of slow reflection or no boxing or other kinds of auxiliary memory allocations are required.<pre><b>[&lt;</b>InferenceRules<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.Rep" href="#dec:type Infers.Rep.Rep">Rep</a>  <b>=</b>
</pre>
<div class="nested"><p> Inference rules for generic type representations.<pre><b>new</b><b>:</b> unit <b>-&gt;</b> Rep
</pre>
<div class="nested"><p> Default constructor.</div>
<pre><b>member</b> <a id="def:member Infers.Rep.Rep.union" href="#dec:member Infers.Rep.Rep.union">union</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Infers.Rep.Union">Union</a><b>&lt;</b><i>'u</i><b>&gt;</b>
</pre>
<div class="nested"><p> Attempts to constructs a union type representation for the type <code><i>'u</i></code>.</div>
<pre><b>member</b> <a id="def:member Infers.Rep.Rep.product" href="#dec:member Infers.Rep.Rep.product">product</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Infers.Rep.Product">Product</a><b>&lt;</b><i>'p</i><b>&gt;</b>
</pre>
<div class="nested"><p> Attempts to construct a product type representation for the type <code><i>'p</i></code>.</div>
<pre><b>member</b> <a id="def:member Infers.Rep.Rep.record" href="#dec:member Infers.Rep.Rep.record">record</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Infers.Rep.Record">Record</a><b>&lt;</b><i>'r</i><b>&gt;</b>
</pre>
<div class="nested"><p> Attempts to constructs a record type representation for the type <code><i>'r</i></code>.</div>
<pre><b>member</b> <a id="def:member Infers.Rep.Rep.tuple" href="#dec:member Infers.Rep.Rep.tuple">tuple</a><b>:</b> unit <b>-&gt;</b> <a href="#def:type Infers.Rep.Tuple">Tuple</a><b>&lt;</b><i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Attempts to constructs a tuple type representation for the type <code><i>'t</i></code>.</div>
<pre><b>member</b> <a id="def:member Infers.Rep.Rep.asElem" href="#dec:member Infers.Rep.Rep.asElem">asElem</a><b>:</b> <a href="#def:type Infers.Rep.Field">Field</a><b>&lt;</b><i>'f</i>, <i>'sp</i>, <i>'r</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Infers.Rep.Elem">Elem</a><b>&lt;</b><i>'f</i>, <i>'sp</i>, <i>'r</i><b>&gt;</b>
</pre>
<div class="nested"><p> Trivially view a field as an elem.</div>
<pre><b>member</b> <a id="def:member Infers.Rep.Rep.asElem" href="#dec:member Infers.Rep.Rep.asElem">asElem</a><b>:</b> <a href="#def:type Infers.Rep.Label">Label</a><b>&lt;</b><i>'l</i>, <i>'sp</i>, <i>'sc</i>, <i>'u</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Infers.Rep.Elem">Elem</a><b>&lt;</b><i>'l</i>, <i>'sp</i>, <i>'u</i><b>&gt;</b>
</pre>
<div class="nested"><p> Trivially view a label as an elem.</div>
</div>
<pre><b>type</b> <a id="def:type Infers.Rep.Empty" href="#dec:type Infers.Rep.Empty">Empty</a>  <b>=</b> <b>struct</b> <b>end</b>
</pre>
<div class="nested"><p> Represents an empty product as a special case for union cases.</div>
<pre><b>[&lt;</b>Struct<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.And" href="#dec:type Infers.Rep.And">And</a><b>&lt;</b><i>'x</i>, <i>'xs</i><b>&gt;</b> <b>=</b>
</pre>
<div class="nested"><p> Represents a pair of the types <code><i>'x</i></code> and <code><i>'xs</i></code>.</p><p> Note that while it is in no way enforced, the idea is that in a nested product the <code><a href="#def:type Infers.Rep.Elem">Elem</a></code> field is the current singleton element and <code><a href="#def:val Infers.Rep.And.Rest">Rest</a></code> is the remainder of the nested produced.  For example, the nested product of the type</p><pre>char <b>*</b> int <b>*</b> float <b>*</b> bool
</pre><p> would be</p><pre><a href="#def:type Infers.Rep.And">And</a><b>&lt;</b>char, <a href="#def:type Infers.Rep.And">And</a><b>&lt;</b>int, <a href="#def:type Infers.Rep.And">And</a><b>&lt;</b>float, bool<b>&gt;&gt;&gt;</b>
</pre><p> The <code>Rep</code> rules generate products in this manner and it is good to know this so that the processing of the singleton <code><a href="#def:type Infers.Rep.Elem">Elem</a></code> field and the remainder product <code><a href="#def:val Infers.Rep.And.Rest">Rest</a></code> can be done in the desired order.<pre><b>val</b> <b>mutable</b> <a id="def:val Infers.Rep.And.Elem" href="#dec:val Infers.Rep.And.Elem">Elem</a><b>:</b> <i>'x</i>
</pre>
<div class="nested"><p> The current element.</div>
<pre><b>val</b> <b>mutable</b> <a id="def:val Infers.Rep.And.Rest" href="#dec:val Infers.Rep.And.Rest">Rest</a><b>:</b> <i>'xs</i>
</pre>
<div class="nested"><p> The remainder of the product.</div>
</div>
<pre><b>[&lt;</b>AbstractClass; InferenceRules<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.AsProduct" href="#dec:type Infers.Rep.AsProduct">AsProduct</a><b>&lt;</b><i>'p</i>, <i>'t</i><b>&gt;</b> <b>=</b>
</pre>
<div class="nested"><p> Representation of the type <code><i>'t</i></code> as nested structs of type <code><i>'p</i></code>.</p><p> A product object also contains members for accessing the elements of the product.  Depending on the type <code><i>'t</i></code> those members are of one of the following forms:</p><pre><b>member</b> _<b>:</b>  <a href="#def:type Infers.Rep.Elem">Elem</a><b>&lt;</b><i>'e</i>, <i>'sp</i>,      <i>'t</i><b>&gt;</b>
<b>member</b> _<b>:</b> <a href="#def:type Infers.Rep.Label">Label</a><b>&lt;</b><i>'l</i>, <i>'sp</i>, <i>'sc</i>, <i>'u</i><b>&gt;</b>
<b>member</b> _<b>:</b> <a href="#def:type Infers.Rep.Field">Field</a><b>&lt;</b><i>'f</i>, <i>'sp</i>,      <i>'r</i><b>&gt;</b>
</pre><p> Those members are visible to inference rules, but they cannot be given a signature in F#.<pre><b>abstract</b> <a id="def:abstract Infers.Rep.AsProduct.Extract" href="#dec:abstract Infers.Rep.AsProduct.Extract">Extract</a><b>:</b> <i>'t</i> <b>*</b> byref<b>&lt;</b><i>'p</i><b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Copies fields of type <code><i>'t</i></code> to the generic product of type <code><i>'p</i></code>.</div>
<pre><b>abstract</b> <a id="def:abstract Infers.Rep.AsProduct.Create" href="#dec:abstract Infers.Rep.AsProduct.Create">Create</a><b>:</b> byref<b>&lt;</b><i>'p</i><b>&gt;</b> <b>-&gt;</b> <i>'t</i>
</pre>
<div class="nested"><p> Creates a new instance of type <code><i>'t</i></code> from the generic product of type <code><i>'p</i></code>.</div>
<pre><b>abstract</b> <a id="def:abstract Infers.Rep.AsProduct.ToProduct" href="#dec:abstract Infers.Rep.AsProduct.ToProduct">ToProduct</a><b>:</b> <i>'t</i> <b>-&gt;</b> <i>'p</i>
</pre>
<div class="nested"><p> Convenience function to convert from product type to nested product.</div>
<pre><b>abstract</b> <a id="def:abstract Infers.Rep.AsProduct.OfProduct" href="#dec:abstract Infers.Rep.AsProduct.OfProduct">OfProduct</a><b>:</b> <i>'p</i> <b>-&gt;</b> <i>'t</i>
</pre>
<div class="nested"><p> Convenience function to convert from nested product to product type.</div>
</div>
<pre><b>[&lt;</b>AbstractClass; InferenceRules<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.AsChoice" href="#dec:type Infers.Rep.AsChoice">AsChoice</a><b>&lt;</b><i>'c</i>, <i>'u</i><b>&gt;</b> <b>=</b> <b>class</b>
  <b>end</b>
</pre>
<div class="nested"><p> Representation of a discriminated union type <code><i>'u</i></code> as nested choices of type <code><i>'c</i></code>.</p><p> A choice object also contains members for accessing individual cases of the choice.  Those members are of the form</p><pre><b>member</b> _<b>:</b> <a href="#def:type Infers.Rep.Case">Case</a><b>&lt;</b><i>'lp</i>, <i>'sc</i>, <i>'u</i><b>&gt;</b>
</pre><p> where <code><i>'lp</i></code> is a representation of the case as product and <code><i>'sc</i></code> is a nested choice that identifies the particular case.</div>
<pre><b>[&lt;</b>AllowNullLiteral; InferenceRules<b>&gt;]</b> 
<b>type</b> <a href="#def:type Infers.Rep.Rep">Rep</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> <b>class</b>
  <b>end</b>
</pre>
<div class="nested"></div>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.Product" href="#dec:type Infers.Rep.Product">Product</a><b>&lt;</b><i>'t</i><b>&gt;</b> <b>=</b>
</pre>
<div class="nested"><p> Type representation for the F# product type (tuple or record) <code><i>'t</i></code>.</p><p> A product object also contains a member of the form</p><pre><b>member</b> _<b>:</b> <a href="#def:type Infers.Rep.AsProduct">AsProduct</a><b>&lt;</b><i>'p</i>, <i>'t</i><b>&gt;</b>
</pre><p> where the type <code><i>'p</i></code> is a representation of the product as a nested record. The member is visible to inference rules, but it cannot be given a signature in F#.<pre><b>val</b> <a id="def:val Infers.Rep.Product.Arity" href="#dec:val Infers.Rep.Product.Arity">Arity</a><b>:</b> int
</pre>
<div class="nested"><p> The number of elements the product type has.</div>
<pre><b>val</b> <a id="def:val Infers.Rep.Product.IsMutable" href="#dec:val Infers.Rep.Product.IsMutable">IsMutable</a><b>:</b> bool
</pre>
<div class="nested"><p> Whether the product type is mutable.</div>
</div>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.Tuple" href="#dec:type Infers.Rep.Tuple">Tuple</a><b>&lt;</b><i>'t</i><b>&gt;</b> <b>=</b>
  inherit <a href="#def:type Infers.Rep.Product">Product</a><b>&lt;</b><i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Type representation for the F# tuple type <code><i>'t</i></code>.</div>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.Elem" href="#dec:type Infers.Rep.Elem">Elem</a><b>&lt;</b><i>'e</i>, <i>'p</i>, <i>'t</i><b>&gt;</b> <b>=</b>
</pre>
<div class="nested"><p> Representation of an element of type <code><i>'e</i></code> of a tuple of type <code><i>'t</i></code>.<pre><b>val</b> <a id="def:val Infers.Rep.Elem.Index" href="#dec:val Infers.Rep.Elem.Index">Index</a><b>:</b> int
</pre>
<div class="nested"><p> The index of the element.</div>
<pre><b>abstract</b> <a id="def:abstract Infers.Rep.Elem.Get" href="#dec:abstract Infers.Rep.Elem.Get">Get</a><b>:</b> <i>'t</i> <b>-&gt;</b> <i>'e</i>
</pre>
<div class="nested"><p> Returns the value of the element.</div>
</div>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.Union" href="#dec:type Infers.Rep.Union">Union</a><b>&lt;</b><i>'u</i><b>&gt;</b> <b>=</b>
</pre>
<div class="nested"><p> Type representation for the F# discriminated union type <code><i>'u</i></code>.</p><p> A union object also contains a member of the form</p><pre><b>member</b> _<b>:</b> <a href="#def:type Infers.Rep.AsChoice">AsChoice</a><b>&lt;</b><i>'c</i>, <i>'u</i><b>&gt;</b>
</pre><p> where type <code><i>'c</i></code> is a representation of the union as nested binary choices. The member is visible to inference rules, but it cannot be given a signature in F#.<pre><b>val</b> <a id="def:val Infers.Rep.Union.Arity" href="#dec:val Infers.Rep.Union.Arity">Arity</a><b>:</b> int
</pre>
<div class="nested"><p> The number of cases the discriminated union type <code><i>'u</i></code> has.</div>
<pre><b>abstract</b> <a id="def:abstract Infers.Rep.Union.Tag" href="#dec:abstract Infers.Rep.Union.Tag">Tag</a><b>:</b> <i>'u</i> <b>-&gt;</b> int
</pre>
<div class="nested"><p> Returns the integer tag of the given discriminated union value.</div>
</div>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.Case" href="#dec:type Infers.Rep.Case">Case</a><b>&lt;</b><i>'lp</i>, <i>'sc</i>, <i>'u</i><b>&gt;</b> <b>=</b>
</pre>
<div class="nested"><p> Representation of a case of the F# discriminated union type <code><i>'u</i></code>.<pre><b>val</b> <a id="def:val Infers.Rep.Case.Name" href="#dec:val Infers.Rep.Case.Name">Name</a><b>:</b> string
</pre>
<div class="nested"><p> The name of the case.</div>
<pre><b>val</b> <a id="def:val Infers.Rep.Case.Arity" href="#dec:val Infers.Rep.Case.Arity">Arity</a><b>:</b> int
</pre>
<div class="nested"><p> The number of elements, or labels, the case contains.</div>
<pre><b>val</b> <a id="def:val Infers.Rep.Case.Tag" href="#dec:val Infers.Rep.Case.Tag">Tag</a><b>:</b> int
</pre>
<div class="nested"><p> The integer tag of the case.</div>
</div>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.Label" href="#dec:type Infers.Rep.Label">Label</a><b>&lt;</b><i>'l</i>, <i>'sp</i>, <i>'sc</i>, <i>'u</i><b>&gt;</b> <b>=</b>
</pre>
<div class="nested"><p> Representation of a possibly labelled element of type <code><i>'l</i></code> of a case of the F# discriminated union type <code><i>'u</i></code>.<pre><b>val</b> <a id="def:val Infers.Rep.Label.Name" href="#dec:val Infers.Rep.Label.Name">Name</a><b>:</b> string
</pre>
<div class="nested"><p> The name of the label.</div>
</div>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.Record" href="#dec:type Infers.Rep.Record">Record</a><b>&lt;</b><i>'r</i><b>&gt;</b> <b>=</b>
  inherit <a href="#def:type Infers.Rep.Product">Product</a><b>&lt;</b><i>'r</i><b>&gt;</b>
</pre>
<div class="nested"><p> Type representation for the F# record type <code><i>'r</i></code>.</div>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="def:type Infers.Rep.Field" href="#dec:type Infers.Rep.Field">Field</a><b>&lt;</b><i>'f</i>, <i>'sp</i>, <i>'r</i><b>&gt;</b> <b>=</b>
</pre>
<div class="nested"><p> Representation of a field of type <code><i>'f</i></code> of the record type <code><i>'r</i></code>.<pre><b>val</b> <a id="def:val Infers.Rep.Field.Name" href="#dec:val Infers.Rep.Field.Name">Name</a><b>:</b> string
</pre>
<div class="nested"><p> The name of the field.</div>
<pre><b>val</b> <a id="def:val Infers.Rep.Field.IsMutable" href="#dec:val Infers.Rep.Field.IsMutable">IsMutable</a><b>:</b> bool
</pre>
<div class="nested"><p> Whether the field is mutable.</div>
<pre><b>abstract</b> <a id="def:abstract Infers.Rep.Field.Set" href="#dec:abstract Infers.Rep.Field.Set">Set</a><b>:</b> <i>'r</i> <b>*</b> <i>'f</i> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Sets the value of the field assuming this is a mutable field.</div>
</div>
</div>
</td></tr></table></body>
</html>
